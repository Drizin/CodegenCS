// Original template source: https://github.com/CodegenCS/Templates/blob/main/SimplePocos/SimplePocos.cs
using CodegenCS;
using CodegenCS.Models.DbSchema;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Diagnostics;

/// <summary>
/// SimplePocos.cs: Given a Database Schema will Generate simple POCOs (just classes and properties, no relationships)
/// </summary>
public class SimplePOCOGenerator
{
    private ICodegenContext _generatorContext;
    private bool _allTablesInSameSchema;
    private SimplePOCOGeneratorOptions _options;

    public SimplePOCOGenerator(SimplePOCOGeneratorOptions options)
    {
        _options = options; // defaults
        _options.Namespace = "MyProject.POCOs";
        _options.SingleFile = true;
        //TODO: _options.DefaultFileName - change extension to ".g.cs"
    }

    #region SimplePOCOGeneratorOptions
    public class SimplePOCOGeneratorOptions
    {
        /// <summary>
        /// Namespace of generated POCOs
        /// </summary>
        public string Namespace { get; set; }

        /// <summary>
        /// If set all POCOs will be generated under a single filename (default output file)
        /// </summary>
        public bool SingleFile { get; set; } = false;

        /// <summary>
        /// If true (default is true) will add [Table] attributes to POCOs.
        /// </summary>
        public bool AddTableAttribute { get; set; } = true;

        /// <summary>
        /// If true (default is true) will add [Key] attributes to primary-key columns.
        /// This is required by FastCRUD and Entity Framework
        /// </summary>
        public bool AddKeyAttribute { get; set; } = true;

        /// <summary>
        /// If true (default is true) will add [DatabaseGenerated] attributes to identity and computed columns.
        /// This is required by FastCRUD and Entity Framework
        /// </summary>
        public bool AddDatabaseGeneratedAttribute { get; set; } = true;

        /// <summary>
        /// If true (default is true) POCOs will have override Equals/GetHashCode and equality/inequality operators (== and !=)
        /// </summary>
        public bool GenerateEqualsHashCode { get; set; } = true;
    }
    #endregion /SimplePOCOGeneratorOptions

    public void Main(ICodegenContext context, IModelFactory factory)
    {
        DatabaseSchema schema = factory.LoadModelFromFile<DatabaseSchema>("AdventureWorksSchema.json");
        _generatorContext = context;
        _allTablesInSameSchema = schema.Tables.Select(t => t.TableSchema).Distinct().Count() == 1;
        GeneratePOCOs(schema);
    }

    /// <summary>
    /// Generates POCOS
    /// </summary>
    public void GeneratePOCOs(DatabaseSchema schema)
    {
        var tablesAndViews = schema.Tables
            .Where(t => ShouldProcessTable(t))
            .OrderBy(t => GetClassNameForTable(t));

        if (_options.SingleFile)
        {
            var singleFile = _generatorContext.DefaultOutputFile;
            singleFile.WriteLine($$"""
            //------------------------------------------------------------------------------
            // <auto-generated>
            //     This code was generated by dotnet-codegencs tool.
            //     Changes to this file may cause incorrect behavior and will be lost if
            //     the code is regenerated.
            // </auto-generated>
            //------------------------------------------------------------------------------
            using System;
            using System.Collections.Generic;
            using System.ComponentModel.DataAnnotations;
            using System.ComponentModel.DataAnnotations.Schema;
            using System.Linq;

            namespace {{_options.Namespace}}
            {
                {{tablesAndViews.Render(table => GeneratePOCO(singleFile, table))}}
            }
            """);
        }
        else
        {
            foreach (var table in tablesAndViews)
            {
                var pocoFile = _generatorContext[GetFileNameForTable(table)];
                GeneratePOCO(pocoFile, table);
            }
        }
    }

    private void GeneratePOCO(ICodegenOutputFile file, Table table)
    {
        if (!_options.SingleFile)
        {
            Debug.WriteLine($"Generating POCO for '{table.TableName}'...");

            file.WriteLine($$"""
                //------------------------------------------------------------------------------
                // <auto-generated>
                //     This code was generated by dotnet-codegencs tool.
                //     Changes to this file may cause incorrect behavior and will be lost if
                //     the code is regenerated.
                // </auto-generated>
                //------------------------------------------------------------------------------
                using System;
                using System.Collections.Generic;
                using System.ComponentModel.DataAnnotations;
                using System.ComponentModel.DataAnnotations.Schema;
                using System.Linq;

                namespace {{_options.Namespace}}
                {
                    {{() => GeneratePOCOClass(file, table)}}
                }
                """);
        }
        else
        {
            Debug.WriteLine($"Generating POCO for {table.TableName} ('{file.RelativePath}')...");
            file.WriteLine($$"""{{() => GeneratePOCOClass(file, table)}}""");
        }
    }

    private void GeneratePOCOClass(ICodegenOutputFile file, Table table)
    {
        string entityClassName = GetClassNameForTable(table);

        if (_options.AddTableAttribute)
        {
            // We'll decorate [Table("Name")] only if schema not default or if table name doesn't match entity name
            if (table.TableSchema != "dbo") //TODO or table different than clas name?
                file.WriteLine($"[Table(\"{table.TableName}\", Schema = \"{table.TableSchema}\")]");
            else if (entityClassName.ToLower() != table.TableName.ToLower())
                file.WriteLine($"[Table(\"{table.TableName}\")]");
        }

        List<string> baseClasses = new List<string>();

        var columns = table.Columns
            .Where(c => ShouldProcessColumn(table, c))
            .OrderBy(c => c.IsPrimaryKeyMember ? 0 : 1)
            .ThenBy(c => c.IsPrimaryKeyMember ? c.OrdinalPosition : 0) // respect PK order... 
            .ThenBy(c => GetPropertyNameForDatabaseColumn(table, c.ColumnName)); // but for other columns do alphabetically;


        file.WithCBlock($"public partial class {entityClassName}{(baseClasses.Any() ? " : " + string.Join(", ", baseClasses) : "")}", () =>
        {
            file.WriteLine($$"""
                #region Members
                {{columns.Render(column => GenerateProperty(file, table, column))}}
                #endregion Members
                """);

            if (_options.GenerateEqualsHashCode)
            {
                file.WriteLine($$"""

                #region Equals/GetHashCode
                {{GenerateEquals(table)}}
                {{GenerateGetHashCode(table)}}
                {{GenerateInequalityOperatorOverloads(table)}}
                #endregion Equals/GetHashCode
                """);
            }
        });
    }

    private void GenerateProperty(ICodegenOutputFile writer, Table table, Column column)
    {
        string propertyName = GetPropertyNameForDatabaseColumn(table, column.ColumnName);
        string privateVariable = $"_{propertyName.Substring(0, 1).ToLower()}{propertyName.Substring(1)}";

        if (column.IsPrimaryKeyMember && _options.AddKeyAttribute)
            writer.WriteLine("[Key]");
        if (column.IsIdentity && _options.AddDatabaseGeneratedAttribute)
            writer.WriteLine("[DatabaseGenerated(DatabaseGeneratedOption.Identity)]");
        else if (column.IsComputed && _options.AddDatabaseGeneratedAttribute)
            writer.WriteLine("[DatabaseGenerated(DatabaseGeneratedOption.Computed)]");

        // We'll decorate [Column("Name")] only if column name doesn't match property name
        if (propertyName.ToLower() != column.ColumnName.ToLower())
            writer.WriteLine($"[Column(\"{column.ColumnName}\")]");
        writer.Write($"public {GetTypeDefinitionForDatabaseColumn(table, column) ?? ""} {propertyName} {{ get; set; }}");
    }

    private FormattableString GenerateEquals(Table table)
    {
        //TODO: GenerateIEquatable, which is a little faster for Generic collections - and our Equals(object other) can reuse this IEquatable<T>.Equals(T other) 

        string entityClassName = GetClassNameForTable(table);
        var cols = table.Columns
            .Where(c => ShouldProcessColumn(table, c))
            .Where(c => !c.IsIdentity)
            .OrderBy(c => GetPropertyNameForDatabaseColumn(table, c.ColumnName))
            .Select(c => new { ColumnName = c.ColumnName, PropertyName = GetPropertyNameForDatabaseColumn(table, c.ColumnName) });

        return $$"""
            public override bool Equals(object obj)
            {
                if (ReferenceEquals(null, obj))
                {
                    return false;
                }
                if (ReferenceEquals(this, obj))
                {
                    return true;
                }
                {{entityClassName}} other = obj as {{entityClassName}};
                if (other == null) return false;

                {{cols.Select(col => $$"""
                    if ({{col.PropertyName}} != other.{{col.PropertyName}})
                        return false;
                    """).Render(RenderEnumerableOptions.LineBreaksWithoutSpacer)}}
                return true;
            }
            """;
    }
    private FormattableString GenerateGetHashCode(Table table)
    {
        var cols = table.Columns
            .Where(c => ShouldProcessColumn(table, c))
            .Where(c => !c.IsIdentity)
            .OrderBy(c => GetPropertyNameForDatabaseColumn(table, c.ColumnName))
            .Select(c => new { ColumnName = c.ColumnName, PropertyName = GetPropertyNameForDatabaseColumn(table, c.ColumnName), DefaultTypeValue = GetDefaultValue(GetTypeForDatabaseColumn(table, c)) });

        //TODO: for dotnetcore we can use HashCode.Combine(field1, field2, field3)
        return $$"""
            public override int GetHashCode()
            {
                unchecked
                {
                    int hash = 17;
                    {{cols.Select(col => $$"""hash = hash * 23 + ({{col.PropertyName}} == {{col.DefaultTypeValue}} ? 0 : {{col.PropertyName}}.GetHashCode());""")}}
                    return hash;
                }
            }
            """;
    }
    private FormattableString GenerateInequalityOperatorOverloads(Table table)
    {
        string entityClassName = GetClassNameForTable(table);
        return $$"""
            public static bool operator ==({{entityClassName}} left, {{entityClassName}} right)
            {
                return Equals(left, right);
            }

            public static bool operator !=({{entityClassName}} left, {{entityClassName}} right)
            {
                return !Equals(left, right);
            }
            """;
    }

    private string GetFileNameForTable(Table table)
    {
        //return $"{table.TableName}.g.cs";
        // default schema or all tables under a single schema - just omit the schema:
        if (table.TableSchema == "dbo" || _allTablesInSameSchema)
            return $"{table.TableName}.g.cs";
        else
            return $"{table.TableSchema}.{table.TableName}.g.cs";
    }
    private string GetClassNameForTable(Table table)
    {
        return $"{table.TableName}";
        if (table.TableSchema == "dbo")
            return $"{table.TableName}";
        else
            return $"{table.TableSchema}_{table.TableName}";
    }
    private bool ShouldProcessTable(Table table)
    {
        if (table.TableType == "VIEW")
            return false;
        if (table.TableName == "Document") // conflicting names //TODO: fix this
            return false;
        if (table.TableName == "EmailAddress") // conflicting names //TODO: fix this
            return false;
        return true;
    }
    private bool ShouldProcessColumn(Table table, Column column)
    {
        string sqlDataType = column.SqlDataType;
        switch (sqlDataType)
        {
            case "hierarchyid":
            case "geography":
                return false;
            default:
                break;
        }

        return true;
    }

    private static Dictionary<Type, string> _typeAlias = new Dictionary<Type, string>
    {
        { typeof(bool), "bool" },
        { typeof(byte), "byte" },
        { typeof(char), "char" },
        { typeof(decimal), "decimal" },
        { typeof(double), "double" },
        { typeof(float), "float" },
        { typeof(int), "int" },
        { typeof(long), "long" },
        { typeof(object), "object" },
        { typeof(sbyte), "sbyte" },
        { typeof(short), "short" },
        { typeof(string), "string" },
        { typeof(uint), "uint" },
        { typeof(ulong), "ulong" },
	    // Yes, this is an odd one.  Technically it's a type though.
	    { typeof(void), "void" }
    };

    private Type GetTypeForDatabaseColumn(Table table, Column column)
    {
        System.Type type;
        try
        {
            type = Type.GetType(column.ClrType);
        }
        catch (Exception ex)
        {
            return null; // ignore vendor specific types that DbSchema doesn't recognize
        }

        bool isNullable = column.IsNullable;

        // Some developers use POCO instances with null Primary Key to represent a new (in-memory) object, so they prefer to set POCO PKs as Nullable 
        //if (column.IsPrimaryKeyMember)
        //    isNullable = true;

        // reference types (basically only strings?) are nullable by default are nullable, no need to make it explicit
        if (!type.IsValueType)
            isNullable = false;

        if (isNullable)
            return typeof(Nullable<>).MakeGenericType(type);

        return type;
    }
    private string GetTypeDefinitionForDatabaseColumn(Table table, Column column)
    {
        //if (column == null)
        //    return null; // IF/IIF symbols will evaluate both TRUE and FALSE statements, but this won't get rendered
        Type type = GetTypeForDatabaseColumn(table, column);
        if (type == null)
            return "?!";

        // unwrap nullable types
        bool isNullable = false;
        Type underlyingType = Nullable.GetUnderlyingType(type) ?? type;
        if (underlyingType != type)
            isNullable = true;

        string typeName = underlyingType.Name;

        // Let's use short type names (int instead of Int32, long instead of Int64, string instead of String, etc)
        if (_typeAlias.TryGetValue(underlyingType, out string alias))
            typeName = alias;

        if (!isNullable)
            return typeName;
        return $"{typeName}?"; // some might prefer $"System.Nullable<{typeName}>"
    }
    private static string GetDefaultValue(Type type)
    {
        // all reference-types default to null
        if (type == null || !type.IsValueType)
            return "null";

        // all nullables default to null
        if (Nullable.GetUnderlyingType(type) != null)
            return "null";

        // Maybe we should replace by 0, DateTime.MinValue, Guid.Empty, etc? 
        string typeName = type.Name;
        // Let's use short type names (int instead of Int32, long instead of Int64, string instead of String, etc)
        if (_typeAlias.TryGetValue(type, out string alias))
            typeName = alias;
        return $"default({typeName})";
    }

    // From PetaPoco - https://github.com/CollaboratingPlatypus/PetaPoco/blob/development/T4Templates/PetaPoco.Core.ttinclude
    private static Regex rxCleanUp = new Regex(@"[^\w\d_]", RegexOptions.Compiled);
    private static string[] cs_keywords = { "abstract", "event", "new", "struct", "as", "explicit", "null",
        "switch", "base", "extern", "object", "this", "bool", "false", "operator", "throw",
        "break", "finally", "out", "true", "byte", "fixed", "override", "try", "case", "float",
        "params", "typeof", "catch", "for", "private", "uint", "char", "foreach", "protected",
        "ulong", "checked", "goto", "public", "unchecked", "class", "if", "readonly", "unsafe",
        "const", "implicit", "ref", "ushort", "continue", "in", "return", "using", "decimal",
        "int", "sbyte", "virtual", "default", "interface", "sealed", "volatile", "delegate",
        "internal", "short", "void", "do", "is", "sizeof", "while", "double", "lock",
        "stackalloc", "else", "long", "static", "enum", "namespace", "string" };

    /// <summary>
    /// Gets a unique identifier name for the column, which doesn't conflict with the POCO class itself or with previous identifiers for this POCO.
    /// </summary>
    /// <param name="table"></param>
    /// <param name="column"></param>
    /// <param name="previouslyUsedIdentifiers"></param>
    /// <returns></returns>
    string GetPropertyNameForDatabaseColumn(Table table, string columnName)
    {
        if (columnName == null)
            return null;
        string name = columnName;

        // Replace forbidden characters
        name = rxCleanUp.Replace(name, "_");

        // Split multiple words
        var parts = splitUpperCase.Split(name).Where(part => part != "_" && part != "-").ToList();
        // we'll put first word into TitleCase except if it's a single-char in lowercase (like vNameOfTable) which we assume is a prefix (like v for views) and should be preserved as is
        // if first world is a single-char in lowercase (like vNameOfTable) which we assume is a prefix (like v for views) and should be preserved as is

        // Recapitalize (to TitleCase) all words
        for (int i = 0; i < parts.Count; i++)
        {
            // if first world is a single-char in lowercase (like vNameOfTable), we assume it's a prefix (like v for views) and should be preserved as is
            if (i == 0 && parts[i].Length == 1 && parts[i].ToLower() != parts[i])
                continue;

            switch (parts[i])
            {
                //case "ID": // don't convert "ID" for "Id"
                //    break;
                default:
                    parts[i] = System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(parts[i].ToLower());
                    break;
            }
        }

        name = string.Join("", parts);

        // can't start with digit
        if (char.IsDigit(name[0]))
            name = "_" + name;

        // can't be a reserved keyword
        if (cs_keywords.Contains(name))
            name = "@" + name;

        return name;
    }

    // Splits both camelCaseWords and also TitleCaseWords. Underscores and dashes are also splitted. Uppercase acronyms are also splitted.
    // E.g. "BusinessEntityID" becomes ["Business","Entity","ID"]
    // E.g. "Employee_SSN" becomes ["employee","_","SSN"]
    private static Regex splitUpperCase = new Regex(@"
        (?<=[A-Z])(?=[A-Z][a-z0-9]) |
            (?<=[^A-Z])(?=[A-Z]) |
            (?<=[A-Za-z0-9])(?=[^A-Za-z0-9])", RegexOptions.IgnorePatternWhitespace);

}
